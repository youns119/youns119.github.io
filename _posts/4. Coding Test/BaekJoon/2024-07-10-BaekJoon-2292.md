---
title:  "[BaekJoon 2292][🟤2] 벌집"
excerpt: "백준 - 2292 문제 풀이"

categories:
  - BaekJoon
tags:
  - [Coding Test, BaekJoon, Mathematics, Binary Search]

toc: true
toc_sticky: true
 
date: 2024-07-10
last_modified_at: 2024-07-10
---

# ❓ 문제

> <https://www.acmicpc.net/problem/2292>

## 🎯 난이도

> Bronze 🟤2

## 🧠 풀이

### 1. 내 풀이 (규칙 찾기)

#### 알고리즘

- `Mathematics`

#### 설명

특정 규칙을 찾아내어 그 규칙에 따라 반복문을 돌며 답을 찾아내는 방식으로 풀었다.

방 하나가 육각형 모양에 시계 방향을 돌며 방이 하나씩 늘어나는 구조이다. `BFS`도 생각해 봤지만 너무 복잡할 것 같았고, `그래프`를 이용한 방식도 힘들어 보여서 결국은 어떠한 규칙을 찾는게 맞는 것 같다는 생각을 했다. 규칙은 생각보다 단순하다.

> 바깥 레이어가 한 겹 늘어날 때마다 늘어가는 방의 갯수가 6개가 더 생긴다.

즉, 각각의 레이어의 방의 갯수를 세어보면 다음과 같다.

<span style = "color:lightblue">
- 1 레이어 : 1개 (1)
- 2 레이어 : 7개 (1 + 6)
- 3 레이어 : 19개 (7 + 12)
- 4 레이어 : 37개 (19 + 18)
</span>

그리고 이는 각 레이어의 `가장 높은 숫자의 방`을 의미하기도 한다. 따라서 이 규칙에 따라 찾으려는 방의 숫자가 어떤 범위의 레이어에 속하는지만 알아내면 답이 나온다.

#### 코드

<details>
<summary style = "color:lightblue">내 풀이 코드</summary>
<div markdown="1">

```cpp
#include <iostream>

using namespace std;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int iN{};
    cin >> iN;

    int iEnd{ 1 };
    int iCnt{ 1 };

    while(iEnd < iN)    // 누적합 구하기
    {
        iEnd += 6 * iCnt;
        ++iCnt;
    }

    cout << iCnt;

    return 0;
}
```

</div>
</details>

### 2. 추가 풀이 (규칙 + 수식화)

#### 알고리즘

- `Mathematics`

#### 설명



#### 코드

<details>
<summary style = "color:lightblue">추가 풀이 코드</summary>
<div markdown="1">

```cpp

```

</div>
</details>

### 2. 추가 풀이 (이분 탐색)

#### 알고리즘

- `Binary Search`

#### 설명


#### 코드

<details>
<summary style = "color:lightblue">추가 풀이 코드</summary>
<div markdown="1">

```cpp

```

</div>
</details>

---
# 💭 후기

어떠한 정수의 전체 `자릿수`의 크기를 알아내는 트릭과 각 `자릿수`를 최소한의 반복만으로 알아내는 방식이 흥미로웠다. 알아두면 앞으로 계속해서 쓸 것 같으니 제대로 숙지해놓자.