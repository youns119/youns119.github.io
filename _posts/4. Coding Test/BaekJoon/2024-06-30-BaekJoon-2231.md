---
title:  "[BaekJoon 2231][🟤2] 분해합"
excerpt: "백준 - 2231 문제 풀이"

categories:
  - BaekJoon
tags:
  - [Coding Test, BaekJoon, Brute Force]

toc: true
toc_sticky: true
 
date: 2024-06-30
last_modified_at: 2024-06-30
---

# ❓ 문제

> [백준 2231 - "분해합"](https://www.acmicpc.net/problem/2231)

## 🎯 난이도

> Bronze 🟤2

## 🧠 풀이

### 1. 내 풀이 (브루트 포스)

#### - 알고리즘

- `Brute Force`

#### - 설명

루프를 돌며 현재 숫자 자체와 그 숫자의 각 자릿수의 숫자를 더하는 방식으로 풀었다. 

안쪽 반복문에서 현재 구현 상으로는 `O(1)`이지만 `pow`라는 비싼 연산도 있고 상수 시간으로 쳐도 **<u>꽤나 비싼 연산</u>**이라 별로 좋지는 않다고 볼 수 있다.

`N` 범위 내의 모든 루프를 돌며 자릿수 체크와 덧셈/뺌셈 연산을 하므로 시간 복잡도는 `O(N)`이라고 할 수 있다. 
{: .notice--info}

#### - 코드

<details>
<summary style = "color:lightblue">내 풀이 코드</summary>
<div markdown="1">

```cpp
#include <iostream>

#include <cmath>


using namespace std;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int iN{};
    int iResult{};
    cin >> iN;

    for(int i = 1; i < iN; ++i)
    {
        int iSum{ i };
        int iTemp{ i };

        for(int j = 6; j >= 0; --j) // 각 자릿수의 숫자를 더함
        {
            int iDivide{ iTemp / static_cast<int>(pow(10, j))};

            if(iDivide == 0)
            {
                continue;
            }

            iTemp -= iDivide * static_cast<int>(pow(10, j));
            iSum += iDivide;
        }

        if(iSum == iN)
        {
            iResult = i;
            break;
        }
    }

    cout << iResult;

    return 0;
}
```

</div>
</details>

---

### 2. 추가 풀이 (최적화된 브루트 포스)

#### - 알고리즘

- `Brute Force`

#### - 설명

내 생각에 가장 정석 풀이인데 생각보다 괜찮은 트릭이 몇 개 있어서 좋은 풀이라고 생각했다.

1. <span style = "color:lightyellow">`int` 자료형을 `string`으로 변환하고 문자열 길이를 통해 자릿수를 구한다.</span>
2. <span style = "color:lightyellow">각 자릿수가 9일 때 자릿수의 합이 최대이므로 `iN - 9 * iDigit`이 최솟값이 된다.</span>
3. <span style = "color:lightyellow">현재 숫자에 `mod` 연산, 나눗셈 연산을 통해 적은 반복으로 각 자릿수 더한다.</span>

이러한 과정을 통해 **<u>상당히 최적화를 할 수 있다.</u>**

시간 복잡도를 `O((log N)²)` 까지 줄였으며, 이는 거의 상수 시간으로 봐도 될 정도로 빠르다.
{: .notice--info}

#### - 코드

<details>
<summary style = "color:lightblue">추가 풀이 코드</summary>
<div markdown="1">

```cpp
#include <iostream>

#include <string>


using namespace std;

int DigitSum(int iInput);

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int iN{};
    int iResult{};
    cin >> iN;

    int iDigit{ static_cast<int>(to_string(iN).length()) }; // string으로 변환한 뒤 문자열 길이로 자릿수 구함
    int iMin{ max(1, iN - 9 * iDigit) };    // 최솟값 구하기

    for(int i = iMin; i < iN; ++i)
    {
        int iSum{ i + DigitSum(i) };

        if(iSum == iN)
        {
            iResult = i;
            break;
        }
    }

    cout << iResult;

    return 0;
}

int DigitSum(int iInput)
{
    int iSum{};

    while(iInput)   // 각 자릿수 더하기
    {
        iSum += iInput % 10;
        iInput /= 10;
    }

    return iSum;
}
```

</div>
</details>

---
# 💭 후기

어떠한 정수의 전체 `자릿수`의 크기를 알아내는 트릭과 각 `자릿수`를 최소한의 반복만으로 알아내는 방식이 흥미로웠다. 알아두면 앞으로 계속해서 쓸 것 같으니 제대로 숙지해놓자.

## 🔗 참고자료

- [브루트 포스 알고리즘](https://youns119.github.io/algorithm/Algorithm-Brute-Force/)