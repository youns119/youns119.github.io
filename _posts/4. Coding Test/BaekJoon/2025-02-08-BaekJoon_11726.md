---
title:  "[BaekJoon 11726][⚪3] 2×n 타일링"
excerpt: "백준 - 11726 문제 풀이"

categories:
  - BaekJoon
tags:
  - [Coding Test, Dynamic Programming]

toc: true
toc_sticky: true
 
date: 2025-02-08
last_modified_at: 2025-02-08
---

# ❓ 문제

> [백준 11726 - "2×n 타일링"](https://www.acmicpc.net/problem/11726)

## 🎯 난이도

> Silver ⚪3

## 🧠 풀이

### 1. 내 풀이 (DP)

#### - 알고리즘

- `Dynamic Programming`

#### - 설명

`DP` 알고리즘을 활용한 풀이이다.

이 문제는 언뜻 보면 어떻게 해야할지 싶지만 의외로 해답은 간단했다. 바로 `규칙`이 존재하기 때문이다. `n`의 값을 `1`씩 늘려가며 결과값을 살펴보면 다음과 같다.

1. <span sytle="color:lightyellow">`n = 1` -> `1`</span>
2. <span sytle="color:lightyellow">`n = 2` -> `2`</span>
3. <span sytle="color:lightyellow">`n = 3` -> `3`</span>
4. <span sytle="color:lightyellow">`n = 4` -> `5`</span>
5. <span sytle="color:lightyellow">`n = 5` -> `8`</span>

위의 결과를 보면, 이는 **<u>'피보나치 수열'과 같은 방식으로 진행</u>**되는 것을 알 수 있다. 따라서 `점화식`도 이에 맞게 만들어 주면 된다.

\\[dp[i] = dp[i - 1] + dp[i - 2]\\]

추가적으로 `피보나치 수열`이 문제의 조건인 `1000`번째까지 가게 되면 엄청나게 커지므로 꼭 반복문의 모든 계산에 `모듈러 연산`을 해주는 것을 잊지 말자.

반복문 하나로 모든 연산이 끝나므로, 시간 복잡도는 `O(N)`이다.
{: .notice--info}

#### - 코드

<details>
<summary style = "color:lightblue">내 풀이 코드</summary>
<div markdown="1">

```cpp
#include <iostream>

#include <vector>


using namespace std;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int iN{};
    cin >> iN;

    // DP 배열
    vector<int> vecDP(iN + 1);
    // 초기값 저장
    vecDP[1] = 1;
    vecDP[2] = 2;

    for(int i = 3; i <= iN; ++i)
    {
        // 오버플로우 방지 위해 항상 모듈러 계산
        vecDP[i] = (vecDP[i - 1] + vecDP[i - 2]) % 10007;
    }

    cout << vecDP[iN];

    return 0;
}
```

</div>
</details>

---
# 💭 후기

처음엔 어떻게 풀어야하나 고민됐지만, 일단 한번 결과값들을 쭉 나열해보자라는 생각이 들었고 의외로 쉽게 `규칙`을 찾을 수 있었다. 이와 같이 도저히 풀이가 생각나지 않을 땐 `규칙`이 있나 곰곰히 생각해보자.

## 🔗 참고자료

- [동적 계획법](https://youns119.github.io/algorithm/Algorithm-Dynamic-Programming/)